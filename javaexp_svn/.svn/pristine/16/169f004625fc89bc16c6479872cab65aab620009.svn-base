package javaexp.z02_homework.a16_jsr;

import java.util.Scanner;

public class A0927 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
/*
# 연휴과제
# 미니프로젝트 1개와 아래 일자별 과제 진행
# 일자별 진행할 내용
# javascript와 java로 처리하고 차이점에 대하여 기술하세요.
*/
/*	
### 09/28 (목요일)
- **개념문제**: 자바의 메모리 분류 및 기본 데이터 유형에 대한 설명.
	java.exe로 프로그램을 실행하면 JVM(자바 가상 머신)은 OS(운영체제)로부터 메모리를 할당받고,
 	그 메모리를 용도에 따라서 세부영역으로 구분해서 사용한다.
		1) 메소드 영역(Method Area)
			메소드 영역에는 코드에서 사용되는 클래스들을 클래스 로드로 읽어 클래스 별로 런타임 상수 풀,
			필드/메소드 데이터,메소드 코드,생성자 코드 등을 분류해서 저장합니다.
			메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역입니다.
		2) 힙 영역(Heap Area)
			힙 영역은 객체와 배열이 생성되는 영역이다. 힙 영역에 생성된 객체와 배열은 스택 영역의
			변수나 다른 객체의 필드에서 참조한다. 참조하는 변수나 필드가 없다면 의미 없는 객체가
			되기 때문에 이것을 쓰레기로 취급하고 GC(가비지 컬렉터)에 의해 자동으로 메모리에서 청소된다.
		3) 스택 영역(Stack Area)
			스택 영역은 각 스레드마다 하나씩 존재라며 스레드가 시작될 떄 할당된다. 자바 프로그램에서
			추가적으로 스레드를 생성하지 않는다면 main스레드만 존재하므로 스택도 하나이다. 스택은
			메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을
			수행한다. 프레임 내부에는 기본 타입 변수와 참조 타입 변수가 추가되거나 삭제된다. 변수는
			선언된 블록 안에서만 스택으로 존재하고 블록을 벗어나면 스택에서 제거된다. 즉 if문, for문
			등에서 내부에서 생성된 변수는 해당 구문을 빠져나오면 제거되어 외부에서 사용할 수 없음을 의마한다.
			다만 배열 같은 경우에는 배열의 변수는 스택영역에서 생성되지만 배열의 데이터 자체는 heap영역에
			생성되어 제거되지 않습니다.
	자바에서 기본 데이터 타입이란 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입을 말한다.
	만약 변수가 사용할 수 있는 값의 번위를 초과하게 되면 오버플로우가 발생하게 된다. 그러면
	내가 원하지 않은 엉뚱한 값이 변수에 들어가게 된다.
		1) 정수타입
			byte(8bit): -2의7승 ~(2의7승-1)
			char(16bit): 0 ~ (2의16승-1),유니코드
			short(16bit): -2의15승 ~ (2의15승-1)
			int(32bit): -2의31승 ~ (2의31승-1)
			long(64bit):  -2의63승 ~ (2의63승-1)
		2) 실수타입
			float(32bit)
			double(64bit)
		3) 논리타입
			boolean(8bit): true, false
	javascript 1) 메모리:  JavaScript에는 Java와 같은 명확한 메모리 영역 구분이 없습니다.
	 					대신, 변수는 크게 기본형(Primitive)과 객체형으로 분류됩니다.
	 		   2) 기본 데이터 타입
	 		   		- 숫자(number): 64비트 부동소수점 형식으로, 모든 숫자를 실수로 처리한다.
	 		   		- 문자열(string): 16비트 유니코드 문자셋(UTF-16)으로 구성된 문자열
	 		   			작은따옴표(''), 큰따옴표(""), 템플릿 리터럴(``)으로 문자열을 할당할 수 있다.
	 		   		- 불리언(boolean): true, false
	 		   		- undefined: 값이 할당되지 않았을 때, 자바스크립트 엔진이 암묵적으로
	 		   		 			초기화하는 값(타입도 값도 모두 undefined)
	 		   		- null: 의도적으로 '값이 없음'을 명시하기 위해 할당하는 값
	 		   			null 타입의 type of 연산 결과는 null이 아니라 object이므로 주의 필요!
	 		   			따라서 null 값 체크를 위해서는 === 일치 연산자를 사용하는게 좋다.
	 		   		- 심벌(symbol): ES6부터 새로 생긴 데이터 타입.
	 		   			변경불가능한 유일한 값을 생성할 때 사용하며, 값 자체의 확인이 불가하여 외부로 노출되지 않는다.
*/
//- **코드연습문제**: 다양한 기본 데이터 유형을 가진 변수를 선언하고 값을 할당하는 코드 작성.
//1. 실수 유형의 10.5 값을 `정수` 유형으로 형변환하여 출력하세요.
//		double a=10.5;
//		System.out.println(a);
//		System.out.println((int)a); //형변환
//2. 변수명으로 적절하지 않은 것들을 선언해보고, 왜 그것이 적절하지 않은지 설명하세요.
//		int #a; //특수문자로 시작하기 위해서는 '_', '$'로 시작해야한다.
//		int _a;
//		int 3a; //숫자로 시작할 수 없다.
		//예약어는 변수로 사용할 수 없다.
//		int break;
//		int for;
		//자바의 변수는 대소문자를 구분한다.
//		int hi;
//		int Hi;
		//변수 길이는 제한이 없고 공백은 포함할 수 없다.
//		int hello java;
//1. let realNumber = 10.5;
//	    let convertedNumber = Math.floor(realNumber);
//	    console.log(convertedNumber);
//
	    // let 123abc; // 숫자로 시작하는 변수명은 허용되지 않습니다.
	    // let my-name; // '-'는 변수 이름에 허용되지 않는 문자입니다.
	    // let for; // 'for'는 자바스크립트의 예약어이기 때문에 변수 이름으로 사용할 수 없습니다.
//---
/*
### 09/29 (금요일)
- **개념문제**: 데이터 유형의 형변환 및 변수 선언 규칙에 대한 이해.
	1. 데이터 유형의 형변환
		코드를 작성하다 보면 같은 타입뿐만이 아니라 서로 다른 타입간의 연산을 수행해야 하는 경우가 있다.
		이럴 때 연산을 수행하기 전에 타입을 일치시켜야 하는데 이를 형변환(casting)이라고 한다
		1) 자동(묵시적)형변환
			메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입에서 큰 타입으로의 타입 변환은 생략할 수 있다.
			byte->short,char->int->long->float->double
		2) 강제(명시적)형변환(casting)
			바이트의 크기가 큰 타입에서 작은 타입으로의 타입 변환은 데이터의 손실이 발생하게 된다.
			따라서, 자바 컴파일러는 오류를 발생시키기 때문에 타입 캐스트 연산자를 통해 강제로 형변환을 해야한다.
			(char)65 -> 'A'
			(int)1.6f -> 1
			(float)10 -> 10.0f
	2. 변수 선언 규칙
		- 첫 문자가 문자나 '_', '$'의 특수문자로 시작되어야 한다. 숫자로 시작할 수 없다.
		  첫 문자가 아니라면, 문자나 '_', '$'의 특수문자 그리고 숫자로 구성될 수 있다.
		- 자바의 예약어는 식별자로 사용할 수 없다.(break,boolean,class,if,new...)
		- 자바의 식별자는 대소문자를 구분한다.
		- 식별자 길이는 제한이 없고 공백은 포함할 수 없다.
		1) 일반적인 변수선언의 관례
			- 클래스 이름은 대문자의 명사로 시작
			- 메서드 이름은 소문자의 동사
			- 변수는 소문자의 명사
			- 상수는 대문자의 명사
*/
//- **코드연습문제**: 형변환을 요구하는 다양한 상황의 코드 작성 및 변수 선언 규칙을 따르는 코드 작성.
//사용자로부터 두 개의 정수 `a`와 `b`를 입력받아, 그 중 어느 수가 큰지 판별하고, 두 수의 합, 차, 
//		곱, 나눗셈의 몫과 나머지를 출력하세요.
//		Scanner sc=new Scanner(System.in);
//		System.out.print("첫번째 숫자를 입력하세요:");
//		int a=sc.nextInt();
//		System.out.print("두번째 숫자를 입력하세요:");
//		int b=sc.nextInt();
//		String result=(a==b)?"같은 수":((a>b)?"첫번째가 큰 수":"두번째가 큰 수");
//		System.out.println(result);
//		System.out.println(a+"+"+b+"="+(a+b));
//		System.out.println(a+"*"+b+"="+a*b);
//		System.out.println(a+"/"+b+"="+a/b);
//		System.out.println(a+"%"+b+"="+a%b);
//---
/*
### 09/30 (토요일)
- **개념문제**: 자바의 연산자들에 대한 설명 및 각 연산자의 용도 이해.
	1. 피연산자 : 연산자의 작업 대상
	2. 연산자 :  연산을 수행하는 기호, 연산자는 피연산자로 연산을 수행하면 항상 결과값을 반환한다.
		1) 산술연산자
			+ : 덧셈
			- : 뺼셈
			* : 곱셈
			/ : 나눗셈
			% : 나머지
		2) 관계(비교)연산자
			> : 좌변 값이 크면 true, 아니면 false
			< : 좌변 값이 작으면 true, 아니면 false
			>= : 좌변 값이 크거나 같으면 true, 아니면 false
			<= : 좌변 값이 작거나 같으면 true, 아니면 false
			== : 두 값이 같으면 true, 아니면 false
			!= : 두 값이 다르면 true, 아니면 false
		3) 논리연산자
			||(OR 결합): 피연산자 중 어느 한쪽만 true이면 true
			&& (AND 결합): 피연산자 모두 true여야 true
			! (NOT): true -> false, false -> true
		4) 대입연산자
			= : 우변의 값을 좌변에 저장
		5) 비트연산자
			a & b: a와 b를 AND 처리(둘 다 1 이어야 1)
			a | b: a와 b를 OR 처리(둘 중 하나만 1 이면 1)
			a ^ b: a와 b를 XOR 처리(두 비트가 달라야지 1)
			a << 2: a를 비트로 변환하여 왼쪽으로 2비트 이동
			a >> 2: a를 비트로 변환하여 오른쪽으로 2비트 이동
		6) 기타연산자
			(type) : 형변환연산자
			조건식 ? 식1 : 식2 (삼항연산자) : 조건식이 true라면 식1, 조건식이 false라면 식2
		##우선순위
		산술 > 비교 > 논리 > 대입 순서로 진행
		대입 연산자는 연산의 진행방향이 오른쪽에서 왼쪽이다.
*/
//- **코드연습문제**: 주어진 문제 상황에 맞는 연산자를 사용하여 코드를 작성.
//사용자로부터 정수를 하나 입력받아, 그 수가 양수인지, 음수인지, 또는 0인지 판별하세요.
//		Scanner sc=new Scanner(System.in);
//		System.out.print("정수를 입력하세요:");
//		int a=sc.nextInt();
//		String result=(a>0)?"양수":((a==0)?"0":"음수");
//		System.out.println(result);
//---
/*
### 10/01 (일요일)
- **개념문제**: 조건문의 개념 및 각 구문의 사용 방법에 대한 이해.
	기본적으로 코드의 실행은 위에서 아래로 한 문장씩 순차적으로 진행지만 때에 따라 주어진 조건과 상황에 맞게끔
	흐름을 바꿔야한다. 이 때, 이 흐름(flow)를 바꾸는 역할을 하는 문장/명령 '제어문(Control Statement)'을
	사용한다. 조건문과 반복문이 바로 제어문에 해당한다.
	1. 조건문
		코드 실행에 대해 조건을 추가하여 각 조건에 해당하는 각 코드 실행을 시키는 명령 기능을 가진 제어문이다.
		블럭({}) : 중괄호이고, 기존 코드들과 다르게 ;를 붙이지 않는다는 것을 명심해야한다.
		1) if문
			조건식이 참이면 괄호안의 문장을 수행한다.
			if (조건식) {
				// 조건식이 참일 경우 수행될 코드 작성
			}
		2) if ~else문
			조건식에 대한 참과 그 밖의 경우(else), 즉 거짓이나 참 외의 상황일 때 실행 할
			코드를 추가해주는 영역이다.
			if (조건식) {
				// 조건식이 참(true)일 때 수행될 문장들을 적는다.
			} else {
				// 조건식은 적을 필요가 없다.
				// 조건식이 거짓(false)일 때 수행될 문장들을 적는다. : if 조건식 제외 나머지 경우
			}
		3) if ~else if문
			if ~else문의 경우는 두 가지 경우에만 적용할 수 있는 조건문이지만 조건 경우의 수가
			3가지 이상의 경우를 처리해야 할 때 사용하는 구문이다.
			if (조건식 1) {
				// 조건식 1이 참일 때 수행될 문장들
			} else if {
				// 조건식 1이 거짓이며 조건식 2는 참일 때 수행될 문장들
			} else if {
				// 조건식 1과 2가 거짓이지만 조건식 3은 참일 때 수행될 문자들 
			} else {
				// 위 모든 조건식에서 모두 참이 아닌 경우 수행될 문장들
			}
		4) 중첩 if문
			조건문뿐만 아니라 반복문도 마찬가지겠지만 횟수 제한 없이 중첩이 가능하다.
			if (조건식1) {
				// 조건식 1이 참일 때 수행될 문장들
				if (조건식 2) {
					// 조건식 1이 참이며 조건식 2도 참일 때 수행될 문장들
				} else if (조건식 3) {
					// 조건식 1이 참이지만 
        			// 조건식 2는 거짓이고 조건식 3은 참일 때 수행될 문장들
				} else {
    				// 조건식 1이 참이지만 
        			// 조건식 2와 3은 거짓일 때 수행될 문장들
    			}
			} else {
				// 조건식 1이 거짓(false)일 때 수행될 문장들을 적는다.
			}
		5) switch문
			if문과 달리 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고, 표현도 간단하다.
			switch (조건식) {
				case 값1 :
    				// 조건식의 결과가 [값1]과 같을 경우 수행
    				break // switch문 벗어나기
    			case 값2 :
    				// 조건식의 결과가 [값2]와 같은 경우 수행
    				break
    			...
    			...
    			default :
    				//조건식 결과와 일치하는 case 없을 경우 수행될 문자
        			//...
			}
			만약, case문 내부의 break;이 없을 경우 밑의 case와 default까지 모두 실행된다.
			##switch문을 쓰기 위해서 지켜져야할 제약조건이 있다.
			-조건식의 결과값은 무조건 정수/문자열이어야 한다.
			-case문의 값 역시 상수 (정수/문자)/문자열만 사용하여야 한다. (변수나 실수 X)
			-중복되지 않아야 한다.
*/
//- **코드연습문제**: 주어진 문제 상황에 맞는 if-else 문 또는 switch-case 문을 사용하여 코드를 작성.
//사용자로부터 정수를 하나 입력받아, 그 수가 양수인지, 음수인지, 또는 0인지 판별하세요.
//---
//		Scanner sc=new Scanner(System.in);
//		System.out.print("정수를 입력하세요:");
//		int a = sc.nextInt();
//1)	if(a>0) {
//			System.out.println("양수");
//		}else if (a==0) {
//			System.out.println("0");
//		}else {
//			System.out.println("음수");
//		}
//2)	int result=(a>0)?1:((a==0)?2:3);
//  	switch (result) {
//		case 1 :
//			System.out.println("양수");
//			break;
//		case 2:
//			System.out.println("0");
//			break;
//		default:
//			System.out.println("음수");
//			break;
//		}
/*
### 10/02 (월요일)
- **개념문제**: 반복문의 개념 및 각 구문의 사용 방법에 대한 이해.
	2. 반복문
	 어떤 작업이 반복적으로 수행되도록 하는 명령문
	 for문은 반복횟수를 알고 있을 때, while문은 횟수를 정확히 알지 못할 때 사용한다고 생각하면 된다.
	 1)for문
	 for (초기화; 조건식; 증감식) {
	 	1)초기화: 횟수의 용도로 사용할 변수의 시작값을 지정해주는 것
	 	 		반복문의 최초로 시작할 때만 실행된다.
	 	 		둘 이상의 변수가 필요한 경우에는 ,(콤마)를 구분자로 변수를 선언해주면 된다.
	 	 		ex)for(int i=1, k=2;i<=10;i++){...}
	 	 			(단, 이 경우에는 두 변수의 타입이 같아야 한다.)
	 	2)조건식: 변수가 언제까지 반복할지 작성해주는 것
	 	  		조건을 통해 참(true)/거짓(false)의 값을 통해 실행/종료를 결정한다.
	 	3)증감식: 연산자들을 활용해서 반복할 때마다 어떻게 연산할지 작성해주는 것
	 	 		i++,1씩 증가
	 	 		i--,1씩 감소
	 	 		i+=2,2씩 증가
	 	 		i*=3,3배씩 증가
	 	 		두 개 이상인 경우에도 각 변수에 해당하는 증감식을 작성해 줄 수 있다.
	 	 		ex) for(int i=1, k=10;i<=10;i++,k--){...}
	 	 			i는 1씩 증가 & k는 1씩 감소
	 	 4)이 매개변수들을 생략해도 오류가 발생하지 않고 이를 활용할 수 있다.
	 	 	for(;;){...} // 모두 생략 : 조건식이 항상 참(true)이 되는 무한반복문
		// 조건식이 참(true)인 동안 수행될 문장들을 적는다.
	}
	//ex) "Just Do It!" 5번 출력하기
	for (int i = 1; i <= 5 ; i++) {
		System.out.println("Just Do IT!");
	}
	2)중첩 for문
		for문 안에 다른 for문을 넣어 중첩으로 수행시킬 수 있다.
		for  (int a = 1; a<=9;a++) {
			for (int b = 1; b <= 9; b++){
				System.out.println(a+"*"+b+"="+a*b); //구구단
			}
		}
	3)while문
		조건식이 참(true)인 동안, 즉 거짓이 될 때까지 블럭 내 문장을 반복한다.
		while (조건식) {
			// 조건식의 연산결과가 참인 동안, 거짓이 될 때까지 반복될 문장들 
		}
	4)do~while 문
		while문의 변형으로 기본적인 구조는 while문과 같지만 조건식과 블럭의 순서가 바뀐 구조이다.
		"반복적으로 사용자의 입력을 받아 비교 및 처리할 때" 주로 사용된다.
		조건식이 뒤에 위치하기 때문에 최소 한 번의 실행은 보장되어 있다.
		do {
			... // "처음 한 번"은 무조건 실행됨.
		} while (조건식) ; // ';' 필수이니 꼭 기억해야한다.
	## break과 continue
		break문 : 자신이 포함된 가장 가까운 반복문을 벗어나게 한다.
		continue문 : (반복문 내에서만 사용 O) 진행 중인던 반복을 끝내고 다음 반복으로 넘어가게 한다.
*/
//- **코드연습문제**: 주어진 문제 상황에 맞는 for, while, do-while 문을 사용하여 코드를 작성.
//1부터 사용자가 입력한 수까지의 모든 정수의 합을 구하세요.
//		Scanner sc=new Scanner(System.in);
//		System.out.print("정수를 입력하세요:");
//		int a = sc.nextInt();
//		int sum=0;
//1)  	for(int i=1;i<=a;i++) {
//			sum+=i;
//		}
//		System.out.println("1부터 "+a+"까지의 합은 "+sum);
//2)	int i =1;
//		while (i<=a) {
//			sum+=i;
//			i++;
//		}
//		System.out.println("1부터 "+a+"까지의 합은 "+sum);
//3)	int i =1;
//		do {
//			sum+=i;
//			i++;
//		} while (i<=a);
//		System.out.println("1부터 "+a+"까지의 합은 "+sum);
//---
/*
### 10/03 (화요일)
- **개념문제**: 자바의 데이터 처리 방식 및 객체의 개념 이해.
	https://sweets1327.tistory.com/61
	자바의 데이터 처리 방식
		1.변수
			1)변수선언
			2)메모리에 변수의 이름과 값을 가진 기억 공간 생성
			3)메모리는 번지로 이루어져 있기 때문에 기억 공간에 대한 번지가 할당된다.
			4)변수 테이블에 변수 이름과 번지 저장
			하지만 이렇게 선언만 하면 해당 변수에는 아무런 값이 존재하지 않습니다.
			따라서, 대입연산자(=)를 사용해서 우항의 데이터를 변수에 할당한다.
		자료형은 크게 기본 자료형과 객체 자료형(참조 자료형)이 있다.
		변수를 저장하면 기본 자료형(stack)과 객체 자료형(heap)은 각기 다른 메모리 영역에 저장된다.
		객체를 생성할 때 객체변수는 기본자료형에 속하여 객체자료형이 생성된 heap영역의 주소를 가진다.
		2.객체 지향 프로그래밍
			객체는 설계도를 바탕으로 만들어진다. 자바에서 설계도는 클래스(class)이다.
			클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
			클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
			하나의 클래스로부터 여러개의 인스턴스를 만들 수 있다.
				1)클래스 설계
					public class 클래스명{
						private int age; //속성값정의
						
						public 클래스명=생성자명(){}//기본생성자 : 객체 생성 위한 메소드
						public 클래스명=생성자명(int age){}//매개변수생성자 : 객체 생성 및 필드 초기화
						
						public void 메소드명(){} //기능 정의 
												[접근제어자]반환형 메소드명(매개변수){기능정의}
						public int 메소드명(){return age;}
					}
					+setter 메소드 : 멤버변수에 변경할 값을 전달받아 값을 변경하는 메소드
					+getter 메소드 : 멤버변수의 값을 읽어 요청한 쪽으로 그 값을 넘기는 메소드
					+this : 현재 객체가 가지고 있는 값을 의미하고 매개변수와 구별하기 위해 사용
				2)설계된 클래스를 가지고 사용할 객체 생성
					main(){
						클래스명 객체변수 = new 클래스명(); 객체 생성(기본생성자)
						클래스명 객체변수 = new 클래스명(매개변수); 객체 생성(매개변수생성자)
						객체변수.속성명 = 속성값; //객체 속성 부여
						객체변수.메서드명(); //메소드 호출
				3)생성된 객체를 이용하기
			1)클래스(Class)
				클래스는 고유성을 가진 객체가 모여 개념화된 특성을 정의한 것이다.
				가장 유명한 예시가 '붕어빵틀'이다 이 붕어빵 틀에서 생성된 객체가 붕어빵이다.
				다시말해 클래스의 정의대로 객체가 연산자를 통해 메모리 영역에 생성되는 것이다.
				객체는 클래스가 없으면 생성되지 못한다.
			2)객체(Object)=인스턴스(Instance)
				객체란 속성과 기능이 묶인 프로그램 단위를 말한다.
				속성(attribute)는 객체가 가진 고유한 특성이고 기능(function)은 객체의 행동 패턴을 말한다.
				속성은 멤버변수이고, 기능은 메소드로 볼 수 있다.
				-메소드(Method)
					메소드는 객체의 동적 처리 내용을 말한다.
					선언은 [접근제어자][반환형][메소드명](매개변수){}로 이루어진다.
					접근제어자의 종류는 public/protected/default/private가 있다.
					클래스는 주로 public으로 선언되어 패키지 안과 밖에서 모두 접근이 가능하게 한다.
					속성(멤버변수)는 주로 private로 선언되어 외부로부터 데이터 변질을 막는다.
					-매개변수X 리턴값O
					public int info(){
						return 0;}
					-매개변수X 리턴값X
					public void info(){
						}
					-매개변수O 리턴값O
					public int info(int age){
						return 0;}
					-매개변수O 리턴값X
					public void info(int age){
						}
				-패키지(Package)
					패키지는 클래스의 묶음이다.
					외부 패키지의 클래스를 사용할 때 패키지를 import해서 사용한다.
*/	
//- **코드연습문제**: 배열과 객체를 활용하는 코드 작성 및 클래스의 구성요소에 따라 메서드와 필드를 가진 클래스 설계.
//사각형 클래스를 만들고, 넓이와 둘레를 구하는 메서드를 포함시키세요. 객체를 생성하고 해당 메서드를 호출하여 결과를 출력하세요.
//		Square sq=new Square(5, 10);
//		sq.squareInfo();
//		sq.area();
//		sq.round();
	}
}
//class Square{
//	private int height;
//	private int row;
//	
//	public Square(int height, int row) {
//		this.height = height;
//		this.row = row;
//	}
//
//	public void area() {
//		System.out.println("사각형의 넓이는:"+height*row); 
//	}
//	public void round() {
//		System.out.println("사각형의 둘레는:"+(height*2+row*2));
//	}
//	public void squareInfo() {
//		System.out.println("#사각형의 정보#");
//		System.out.println("사각형의 높이:"+height);
//		System.out.println("사각형의 밑변:"+row);
//	}
//}
